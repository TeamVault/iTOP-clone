from autocoop.builder.builder import *
import autocoop.esl_lib.lib_utils.candidate_finder as candidate_finder
import autocoop.esl_lib.lib_utils.capstone_utils as capstone_utils
import logging
import angr
from capstone import arm64
import itertools

def generate_main(app, config, calltargets_order):
    """
    Generates the object dispatch loop gadget and the array builder.

    The the offsets for the object array ptr and the object array length are generated by stepping though the
    disassembled code, from the virtual function call/the loop exit condition, tracking the relevant registers until
    the offset is found.

    :param angr.Project app: application the gadget will be found for
    :param Config config: configuration of the exploit generator
    :param list[int] calltargets_order: list of calltargets in the order they are called in
    :return: Array builder object ready for more objects to be added and vptr offset

    """
    logger = logging.getLogger("autocoop.esl_lib.mainloop")
    logger.info("[*] Building Callsite Candidate Set")
    # app.analyses.CFGFast()
    min_addr = app.loader.main_object.min_addr
    if config.other_args.get("policy", None):
        candidates = list(candidate_finder.get_candidate_callsites_from_csv(app, config.other_args["gadget_csv"]))
    else:
        candidates = list(candidate_finder.get_all_functions(app))
        candidates_new = []
        for vtbl, candidate in candidates:
            candidates_new.append((vtbl, candidate) + (candidate.rebased_addr-min_addr, None))
        candidates = candidates_new
    for vtable, gadget, offset, calltargets_raw in candidates:
        if type(gadget) == int:
            gadget = app.loader.find_symbol(min_addr+offset)
        logger.info("[*] Evaluating potential LINKEDLIST gadget: {}".format(gadget))
        insns = capstone_utils.get_function_capstone(app, gadget)
        # 1. find call
        # 2. find target object offset
        # 3. find exit condition
        # 4. find node origin
        # 5. find next node offset
        call_index = 0
        while call_index < len(insns):
            if insns[call_index].mnemonic == "call":
                break
            call_index += 1
        else:
            continue
        logger.info("[!] Finished step 1 (find call): {}".format(gadget))
        call_ins = insns[call_index]
        if call_ins.mnemonic != "call":
            continue
        if len(call_ins.operands) != 1:
            continue
        operand = call_ins.operands[0]
        if operand.type != arm64.ARM64_OP_MEM:
            continue
        if operand.mem.base == 0:
            continue
        config.vptr_offset = operand.mem.disp / 8

        target_object_offset = None
        first_deref_found = False
        target_obj_index = call_index
        reg = operand.mem.base
        app.kb.virtual_dispatch = not "rdi" == call_ins.insn.reg_name(reg)

        while target_obj_index > 0:
            target_obj_index -= 1
            res = capstone_utils.find_reg_source(insns[target_obj_index], reg)
            if not res:
                continue
            if res[1] == None:
                reg, _, _, _ = res
                continue
            if not first_deref_found:
                reg, _, _, _ = res
                first_deref_found = True
            else:
                reg, target_object_offset, _, _ = res
                break
        if target_object_offset == None:
            continue
        logger.info("[!] Finished step 2 (find target object offset): {}".format(gadget))

        condition_index = call_index
        visited = set()
        reg = None
        invalid = False
        jumpto = None
        jumpfrom = None
        while condition_index and condition_index+1 < len(insns) and condition_index+1 not in visited:
            condition_index += 1
            visited.add(condition_index)
            insn = insns[condition_index].insn
            if insn.mnemonic == "jmp":
                if insn.operands[0].type == arm64.ARM64_OP_IMM:
                    target = insn.operands[0].imm
                    condition_index = capstone_utils.find_index_for_addr(insns, target)
            elif insn.mnemonic.startswith("j"):
                if capstone_utils.find_index_for_addr(insns, insn.operands[0].imm) <= call_index:
                    jumpto = capstone_utils.find_index_for_addr(insns, insn.operands[0].imm)
                    jumpfrom = condition_index
                    for i in range(5):
                        condition_index -= 1
                        insn = insns[condition_index].insn

                        if insn.mnemonic == "test":
                            if insn.operands[0].type == arm64.ARM64_OP_REG:
                                reg = insn.operands[0].reg
                                break
                    else:
                        invalid = True
                    if not invalid:
                        break
            elif insn.mnemonic == "call":
                invalid=True
        else:
            continue
        if invalid:
            continue

        logger.info("[!] Finished step 3 (find exit condition): {}".format(gadget))

        index = condition_index
        node_origin = None
        while index > 0:
            index -= 1
            insn = insns[index].insn
            res = capstone_utils.find_reg_source(insn, reg)
            if res and res[1] != None:
                node_origin = res
                break
        else:
            continue

        node_origin_offset = node_origin[1]
        logger.info("[!] Finished step 4 (find node origin): {}".format(gadget))
        source_reg = None
        next_node_offset = None
        while index > 0:
            index -= 1
            insn = insns[index].insn
            if "mov" in insn.mnemonic:
                operand = insn.operands[0]
                if node_origin == (operand.mem.base, operand.mem.disp, operand.mem.index, operand.mem.scale):
                    source_reg = insn.operands[1].reg
                    break
                if node_origin[0] == operand.reg and node_origin[1] == 0:
                    source_reg = insn.operands[1].mem.base
                    next_node_offset = insn.operands[1].mem.disp
                    next_node_offset, node_origin_offset = node_origin_offset, next_node_offset
                    break
        else:
            continue
        if not source_reg:
            continue
        if next_node_offset is None:
            visited = set()
            stop = False
            while not stop and (index != condition_index and (index-1) not in visited and index > 0):
                index -= 1
                visited.add(index)
                insn = insns[index].insn
                res = capstone_utils.find_reg_source(insn, source_reg)
                if not res:
                    stop=True
                    continue
                elif res[1] == None:
                    source_reg = res[0]
                    continue
                if res:
                    _, next_node_offset, _, _ = res
                    break
                if index == jumpto:
                    index = jumpfrom
            else:
                continue
        nno_index = index
        invalid = False
        while index > call_index:
            index -= 1
            insn = insns[index].insn
            if insn.mnemonic.startswith("j"):
                if capstone_utils.find_index_for_addr(insns, insn.operands[0].imm) > index:
                    print "Hit invalid jump"
                    invalid = True
                    break
        if invalid:
            continue
        logger.info("[!] Finished step 5 (find next node offset): {}".format(gadget))
        if vtable == 1:
            initObj = Object(vIndex=0, vFunc=gadget.rebased_addr, noFakeVtable=False, fixedOffset=0)
        else:
            initObj = Obj64(fixedOffset=0)
            initObj.setVptr(vtable)
        initObj.mem.addUnresolvedPointer(node_origin_offset, LinkedListBuilder.LABEL_BASE_LL)
        b = LinkedListBuilder(config.base_buf, offsetPtrObj=target_object_offset, offsetPtrNext=next_node_offset, mainObj=initObj, arch=Arch.X64, node_origin_offset=node_origin_offset)
        initObj.setLabel(532523)
        app.kb.next_node_offset = node_origin_offset
        app.kb.initial_object_label = 532523
        if config.other_args.get("dispatcheranalysis", None):
            calltargets = None
        else:
            if calltargets_raw:
                calltargets = candidate_finder.get_candidate_gadgets_from_line(app, calltargets_raw, config.other_args["policy"])
            else:
                calltargets = candidate_finder.get_all_functions(app)

        # import IPython; IPython.embed()
        yield b, gadget, calltargets
    raise StopIteration("No candidate callsites left.")


def update_main(ll_builder, calltargets):
    """
    Adds objects to array builder

    :param ll_builder: Linked List builder to add objects to
    :param list calltargets: list of calltargets and builder objects
    """
    labels = {}
    for i, (_, gadget, _) in enumerate(calltargets):
        if hasattr(gadget, "target_value"):
            # if not gadget.label:
            #     gadget.label = gadget.target_addr_label
            # labels[gadget.label] = gadget.target_addr_label
            labels[gadget.conditional_label] = gadget.target_value
    print labels
    for i, (_, gadget, obj) in enumerate(calltargets):
        lastObj = (i == len(calltargets) -1) and not gadget.next_label
        if gadget.label and gadget.label not in labels:
            labels[gadget.label] = ll_builder.labelLl
        if gadget.next_label and gadget.next_label not in labels:
            labels[gadget.next_label] = hash(gadget.next_label)

        if not (i == len(calltargets) - 1):
            next_object = calltargets[i+1][1]
            if next_object.label and not gadget.next_label:
                gadget.next_label = next_object.label
        ll_builder.addObj(obj, labelNextItem=labels.get(gadget.next_label, None), labelItem=labels.get(gadget.label, None), lastObj=lastObj)


gadget = generate_main, update_main