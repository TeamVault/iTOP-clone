import csv
from elftools.elf.elffile import ELFFile
import angr
import logging
import subprocess
import pickle
import os

def get_candidate_gadgets_from_csv(app, csv_path, policy):
    """
    Finds the addresses of all candidate gadgets based on the info in the csv file generated by CFI assessor

    :param angr.Project app: application the gadgets should be found in
    :param str csv_path: path to the CFI assessor candidate gadget csv file
    :param str policy: policy to look out for
    :return: list of candidate gadgets, described by their vtable address and Symbol in app
    :rtype: list[(int, angr.Symbol)]
    """
    if app.kb.__dict__.get("candidates"):
        return app.kb.candidates
    logging.getLogger("autocoop.candidate_finder").info("[*] getting candidate calltargets")
    with open(csv_path, 'r') as csv_file:
        reader = csv.reader(csv_file)
        targets = []
        found = set()
        for line in reader:
            targetlist_found = False
            for cell in line:
                cell = cell.strip()
                if (policy+"(") in cell and not targetlist_found:
                    targetlist_found = True
                elif targetlist_found and cell not in found:
                    if cell.endswith("):"):
                        break
                    if cell.startswith("_") and app.loader.find_symbol(cell) != None:
                        targets.append((cell, app.loader.find_symbol(cell)))
                        found.add(cell)
                    elif get_symbol_of_demangled_name(app, cell):
                        targets.append((cell, get_symbol_of_demangled_name(app, cell)))
                        found.add(cell)
    result = []
    for name, symbol in targets:
        vtbl = 1 # get_vtbl_address(app, symbol)
        result.append((vtbl, symbol))
    if not result:
        return get_all_functions(app)
    return result

def get_candidate_gadgets_from_line(app, line, policy):
    """
    Finds the addresses of all candidate gadgets based on the info in the csv file generated by CFI assessor

    :param angr.Project app: application the gadgets should be found in
    :param list[str] line: a line from the csv file describing calltargets
    :return: list of candidate gadgets, described by their vtable address and Symbol in app
    :rtype: list[(int, angr.Symbol)]
    """
    global names_reverse
    logging.getLogger("autocoop.candidate_finder").info("[*] getting candidate calltargets for callsite")
    targetlist_found = False
    targets = []
    for cell in line:
        cell = cell.strip()
        if (policy+"(") in cell and not targetlist_found:
            targetlist_found = True
        elif targetlist_found:
            if "):" in cell:
                break
            symbol = app.loader.find_symbol(cell)
            if cell.startswith("_") and symbol:
                targets.append((cell, symbol))
            elif get_symbol_of_demangled_name(app, cell):
                targets.append((cell, get_symbol_of_demangled_name(app, cell)))
    generate_names_reverse(app, [target[0] for target in targets])
    print len(targets)
    result = []
    for name, symbol in targets:
        vtbl = get_vtbl_address(app, symbol)
        result.append((vtbl, symbol))
    if not result:
        return get_all_functions(app)
    return result

def get_classname(name):
    """
    Extracts the classname from a demangled name

    :param name: Name to extract classname from
    :return: Extracted name
    :rtype: str
    """
    if name.endswith(")"):
        split = name.split("(")[0]
    else:
        split = name
    split = split.split(":")[:-1]
    classname = ":".join(split)
    if "<" in classname and not ">" in classname:
        split = classname.split("<")[:-1]
        join = "<".join(split)
        split = join.split(":")[:-1]
        classname = ":".join(split)
    if classname.endswith(":"):
        classname = classname[:-1]
    classname = classname.split(" ")[-1]
    return classname

def generate_hashed_filename(app, filename):
    csv = app.config_class.other_args.get("gadget_csv", None)
    mtime = os.path.getmtime(filename)
    return str(hash(hash(filename) + hash(mtime) + hash(csv) + hash(app.config_class.other_args.get("policy", None))))

def write_cache_file(app, name, data):
    """
    Caches an object

    :param app: Parent angr project
    :param name: Name of object to write
    :param data: Data to write
    """
    filename = "cache/c_" + generate_hashed_filename(app, app.filename) + "_" + name + ".pickle"
    with open(filename, "w") as f:
        pickle.dump(data, f)


def load_cache_file(app, name):
    """
    Loads a chached file

    :param app: Parent angr project
    :param name: Name of object to read
    :return: Loaded object
    """
    filename = "cache/c_" + generate_hashed_filename(app, app.filename) + "_" + name + ".pickle"
    with open(filename, "r") as f:
        return pickle.load(f)

symbols_reverse = {}


def get_symbol_of_demangled_name(app, name):
    """
    Gets the symbol that matches the demangled name

    :param angr.Project app: application the symbol should be found in
    :param str name: demangled name to be found
    :return: Symbol object with matching demangled name
    """
    global symbols_reverse
    if symbols_reverse:
        return symbols_reverse.get(name, None)
    else:
        logging.getLogger("autocoop.candidate_finder").info("[*] building demangled name dictionary")
        try:
            symbols_reverse_addr = load_cache_file(app, "symbols_reverse")
            for key, value in symbols_reverse_addr:
                symbols_reverse[key] = app.loader.main_object.symbols_by_addr[value]
        except:
            symbols = list(app.loader.main_object.symbols_by_addr.items())
            demangled_names = demangle_many(symbols)
            for (addr, symbol), demangled in zip(symbols, demangled_names):
                symbols_reverse[demangled] = symbol
            if not symbols_reverse:
                symbols_reverse = {1: None}

            symbols_reverse_addr = {}
            for key, value in symbols_reverse.items():
                symbols_reverse_addr[key] = value.rebased_addr
            write_cache_file(app, "symbols_reverse", symbols_reverse_addr)
            return get_symbol_of_demangled_name(app, name)

names_reverse = {}
def get_demangled_name_of_symbol(app, symbol):
    global names_reverse
    res = names_reverse.get(symbol.name, None)

def generate_names_reverse(app, names):
    names_new = []
    for name in names:
        if name not in names_reverse:
            names_new.append(name)
    demangled_names = demangle_many(names_new)
    for k,v in zip(names, demangled_names):
        names_reverse[k] = v



def demangle_many(symbols):
    """
    The names of these symbols, run through a c++ demangler

    :warning: this calls out to the external program `c++filt` and will fail loudly if it's not installed

    :param list symbols: list of tuples of address/symbol pairs
    :return: demangled names
    :rtype: list[str]
    """
    if not symbols:
        return []
    if type(symbols[0]) == tuple:
        name_arr = [symbol.name.split("@@")[0] for addr, symbol in symbols]
    else:
        name_arr = [name.split("@@")[0] for name in symbols]
    args = ["c++filt"]
    pipe = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    demangled = []
    for name in name_arr:
        pipe.stdin.write("{}\n".format(name))
        demangled += [pipe.stdout.readline()]
    pipe.stdin.close()
    pipe.wait()
    demangled += pipe.stdout.readlines()
    return [d.strip() for d in demangled]


def get_candidate_callsites_from_csv(app, csv_path):
    """
    Finds the addresses of all candidate callsites based on the csv generated by CFI Assessor

    :param angr.Project app: application the callsites should be found in
    :param str csv_path: path to the CFI assessor callsite csv file
    :return: list of candidate functions containing callsites, described by their vtable address, Symbol in app, and
      address of the callsite itself

    :rtype: list[(int, angr.Symbol, int)]
    """
    line_numbers = set()
    files = set()
    calltarget_list_raw = dict()
    with open(csv_path, 'r') as csv_file:
        reader = csv.reader(csv_file)
        for line in reader:
            split = line[0].split(":")
            if len(split) != 3:
                continue
            filename = split[0].split("/")[-1]
            rest_of_line = line[1:]
            calltarget_list_raw[(filename, int(split[1]))] = rest_of_line
            line_numbers.add((filename, int(split[1])))
            files.add(filename)
    addresses = []
    with open(app.filename, "rb") as f:
        try:
            addresses = load_cache_file(app, "addresses")
            for i in addresses:
                yield i
            # for a,b,c,d in addresses:
            #     yield (a,app.loader.main_object.symbols_by_addr[c+app.loader.main_object.min_addr],c+app.loader.main_object.min_addr,d)
            # return
        except Exception as e:
            logging.getLogger("autocoop.candidate_finder").info("[*] getting dwarf info")
            elffile = ELFFile(f)
            assert(elffile.has_dwarf_info())
            dwarfinfo = elffile.get_dwarf_info()
            total = sum(1 for _ in dwarfinfo.iter_CUs())
            count = 0
            for CU in dwarfinfo.iter_CUs():
                count += 1
                logging.getLogger("autocoop.candidate_finder").info("[*] Checking CU {}/{}".format(count, total))
                lineprog = dwarfinfo.line_program_for_CU(CU)
                for entry in lineprog.get_entries():
                    if entry.state is None or entry.state.end_sequence:
                        continue
                    line = entry.state.line
                    name = lineprog["file_entry"][entry.state.file - 1].name
                    if (name, line) in line_numbers and not (name, line) in addresses:
                        if (name, line) in addresses:
                            print name, line, addresses[(name, line)], entry.state.address
                        address = entry.state.address
                        symbol, address = get_symbol_for_address(app, address)
                        vtbl = get_vtbl_address(app, symbol)
                        yield (vtbl, 0, address-app.loader.main_object.min_addr, calltarget_list_raw[(name, line)])
                        addresses.append((vtbl, 0, address-app.loader.main_object.min_addr, calltarget_list_raw[(name, line)]))

            write_cache_file(app, "addresses", addresses)


def get_vtbl_address(app, gadget):
    """
    Gets the vtable address for gadgets or marks the gadget for fake vtable generation if none are found

    :param app: Parent angr project 4194304
    :param gadget: Gadget to find vtable addr for
    :return: Vtable addr
    :rtype: int
    """
    vtbl = app.kb.vtbls.get(gadget.name, None)
    if vtbl:
        return vtbl
    classname = get_classname(gadget.demangled_name)
    vtbl = get_symbol_of_demangled_name(app, "vtable for {}".format(classname))
    if not vtbl:
        app.kb.vtbls[gadget.name] = 1
        return 1
    for addr in range(vtbl.rebased_addr, vtbl.rebased_addr+vtbl.size, 8):
        value = app.kb.entry_state.mem[addr].uintptr_t
        if not value.resolvable:
            continue
        value = value.concrete
        if value == gadget.rebased_addr:
            app.kb.vtbls[gadget.name] = addr
            return addr
    app.kb.vtbls[gadget.name] = 1
    return 1


def get_symbol_for_address(app, address):
    """
    Gets the symbol corresponding to an address. If no symbol exactly matches the address, the symbol with the next
    smaller address is returned.

    :param angr.Project app: application the symbol should be found in
    :param int address: address to be searched for
    :return: Symbol object with (roughly) matching address
    """
    closest = -1
    if address + app.loader.main_object.min_addr <= app.loader.main_object.max_addr:
        address = address + app.loader.main_object.min_addr
    for addr, symbol in app.loader.main_object.symbols_by_addr.items():
        if addr > closest and addr <= address:
            closest = addr
    return app.loader.main_object.symbols_by_addr[closest], closest


def get_all_functions(app):
    """
    Gets all functions in the application

    :param angr.Project app: application the functions should be found in
    :return: list of candidate gadgets, described by their vtable address and Symbol in app
    :rtype: list[(int, angr.Symbol)]
    """
    candidates = []
    for a_object in app.loader.all_objects:
        for addr, symbol in a_object.symbols_by_addr.items():
            if symbol.is_function:
                # vtbl = get_vtbl_address(app, symbol)
                candidates.append((1, symbol))
    return candidates # [93821:]

if __name__ == '__main__':
    app = angr.Project("exploitable_app/cmake-build-debug/libAPP.so", auto_load_libs=True,
                                       main_opts={"custom_base_addr": 0x7ffff7ff2000})
    print get_candidate_callsites_from_csv(app, "exploitable_app/cmake-build-debug/SDOutput/libAPP.so-Virtual-metric.csv")

